package cs265;


import static org.testng.AssertJUnit.assertEquals;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.testng.ITestResult;
import org.testng.annotations.AfterClass;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;
import org.apache.commons.io.FileUtils;
import org.openqa.selenium.By;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.Wait;
import org.openqa.selenium.support.ui.WebDriverWait;



public class CS265_Lab_W09 {

    // declare the web driver for the Chrome browser.
	// declare these as STATIC variables so they are visible in the
	// rest of this class

	static WebDriver driver1 ;
	static Wait<WebDriver> wait;
	static String URL_TO_TEST = "http://www.cs.nuim.ie/~pmooney/CS265B/2017/triangle.php";

	// What do we want done BEFORE this class (CS265B_Selenium_Lab7) starts
	// this usually means STARTING up the web driver with the browser.
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {

		System.setProperty("webdriver.chrome.driver", "C:\\Users\\haon9\\Documents\\chromedriver_win32\\chromedriver.exe");

		driver1 = new ChromeDriver();
		wait = new WebDriverWait(driver1,1);
		System.out.println("CS265 Selenium Lab: TESTING READY TO BEGIN");
	}

	// What do we want done AFER this class (CS265B_Selenium_Lab7) finishes
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		driver1.close();
		driver1.quit(); // close the drivers
		System.out.println("CS265 Selenium Lab: TESTING FINISHED");
	}


	// This method will perform any specific requirements
	// Make sure that the page is fully loaded
	@BeforeMethod
	public void setUp() throws Exception {
        driver1.get(URL_TO_TEST);
    	// ensure that the windows open at maximum (better for us to see)
    	//driver1.manage().window().maximize();
    	// wait until displayed
    	// The page is fully loaded when the Submit Button Appears
    	wait.until(ExpectedConditions.presenceOfElementLocated(By.id("theSubmitButton")));
	}



	// Create a template of the test we want to run over and over again
	// This is the template and it will need to match the INPUT form
	// and any other input we have. You'll also need to provide the expected
	// output or answer
	// ALL INPUT TO FORMS IN HTML ARE STRING DATA TYPE

	public static void CS265BLab7_TestTemplate(String s1,String s2, String s3,
			String expectedAns)
	{
		// print some messages to the console.
		System.out.println("START: The page title is now " + driver1.getTitle());

		// Look into the source code (VIEW SOURCE) of the ex1.php page

		// Automatically put some data into each of the three text boxes

		driver1.findElement(By.id("angle1")).sendKeys(s1);

		driver1.findElement(By.id("angle2")).sendKeys(s2);

		driver1.findElement(By.id("angle3")).sendKeys(s3);

		driver1.findElement(By.id("theSubmitButton")).submit();
		// hit the submit button automatically
		// We need to find the id of the submit button in the source code

		System.out.println("PROCESS: The page title is now " + driver1.getTitle());

		// The answer (if you view the source of the processed page)
		// is in a DIV called 'answer' - this is the id.
		// extract the text from that DIV.

		String answerGenerated = driver1.findElement(By.id("triangle")).getText();

		System.out.println("The answer generated by the Triangle PHP processor is [" + answerGenerated + "]");

		// This is where we put the expected output of our test
		// based on our input above.

		String expectedAnswer = expectedAns;

		// Write some stuff to the console.
		System.out.println("CS265 TESTING: Our expected answer is [" + expectedAnswer + "]");

		// Wait for four seconds so you can physically see the output
		// 1000 milliseconds is 1 seconds
		try {
			Thread.sleep(40);
			System.out.println("CS265 FINISHED SLEEPING");
		} catch (InterruptedException e) {

			e.printStackTrace();
		}
		// Get TestNG to compare the two answers
		// Report a failure if this is the case
		// Compare the expected answer and the generated answer from the application
		assertEquals(expectedAnswer,answerGenerated);

	}

	// Generate a test with VALID input data.
	// Notice that this method has the same parameters as our testing template above.
	// It calls the CS265BLab7_TestTemplate from above.

	@Test(dataProvider="validData",description="Testing the application with VALID input data")
	public void validDataTests(String s1, String s2, String s3, String ans)
	{
		CS265BLab7_TestTemplate(s1,s2,s3,ans);
	}

	// Generate a test with INVALID input data.
	// Notice that this method has the same parameters as our testing template above.
	// It calls the CS265BLab7_TestTemplate from above.

	@Test(dataProvider="invalidData",description="Testing the application with INVALID input data")
	public void invalidDataTests(String s1, String s2, String s3, String ans)
	{
		CS265BLab7_TestTemplate(s1,s2,s3,ans);
	}

	// Create your DATA PROVIDER for validData.
	// create the valid data for the valid data tests.
	// NOTICE - the structure of the multidimensional array in this method
	// has the same order as the INPUT parameters for both the data provider methods
	// AND the CS265BLab7_TestTemplate method.
	// Here are some example tests

	@DataProvider(name="validData")
	public static Object[][] createValidData()
	{
		// MORE CAN BE ADDED HERE
		Object[][] validData =
		{
		{"60","60","60","EQUILATERAL"},
		{"60","70","50","SCALENE"},
		{"60","20","120","SCALENE"},
		{"60","20","120","SCALENE"},
		{"90","60","30","RIGHT ANGLE TRIANGLE"},
		{"30","60","90","RIGHT ANGLE TRIANGLE"}
		};
		return validData;

	}

	// Create your DATA PROVIDER for invalidData.
	// create the valid data for the invalid data tests.
	// NOTICE - the structure of the multidimensional array in this method
	// has the same order as the INPUT parameters for both the data provider methods
	// AND the CS265BLab7_TestTemplate method.
	@DataProvider(name="invalidData")
	public static Object[][] createInValidData()
	{
		// MORE CAN BE ADDED HERE
		Object[][] invalidData =
		{

		{"60","0","60","ZERO ANGLES"},
		{"60","160","60","GREATER THAN 180"},
		{"-60","160","60","NEGATIVE ANGLES"},
		{"60","","60","INVALID TRIANGLE"},
		};
		return invalidData;

	}


	/*
	 * This is a very useful method - this method will take a timestamped screenshot
	 * automatically of ANY test that fails. It will take a screenshot of the
	 * web-browser in the state that cause the failure.
	 * The screenshots are in PNG format and shall be written directly to your Eclipse
	 * workspace where the folder for this project is stored.
	 * The annotation @AfterMethod means that it will ONLY RUN after a
	 * test method has been run.
	 */

    @AfterMethod
    public void takeScreenShotOnFailure(ITestResult testResult) throws IOException {
        if (testResult.getStatus() == ITestResult.FAILURE) {
            System.out.println(testResult.getStatus());
            // Create a reasonably unique filename
            // with the current timestamp in mm-ss resolution

            String fn = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss").format(new Date()).toString();

            fn = "CS265_SeleniumLab_FailedTest_" + fn + ".png";

            File scrFile = ((TakesScreenshot) driver1).getScreenshotAs(OutputType.FILE);
            FileUtils.copyFile(scrFile, new File(fn));
        }
    }



}
